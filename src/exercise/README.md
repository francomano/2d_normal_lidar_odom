# 2D Normal-Based Lidar Odometry
In this project, your task is to extend the 2D ICP Lidar Odometry illustrated during the course (located at `exercise/rp_10_scan_matcher`) by:

-   Extend the CMake configuration file to include NICP modules
-   Implement the support for Normal ICP
-   Replacing the Frame-To-Frame odometry fashion with a Frame-To-KeyFrame odometry

We provide a project structure which already contains a working example of Frame-To-Frame odometry 

## Normal ICP
One of the major pitfalls of P2P ICP (point-to-point) is the number of local minima solutions caused by wrong correspondences computed during the alignment process. The cause relates to the nearest neighbors approach used to compute the correspondences, and the sparsity of the scan itself.

Integrating surface information during the alignment process, allows the moving cloud to "slide" along planar surfaces thus removing most of the local minima constrained solutions.

We define a new point type `PointNormal2f` containing:
1. Point coordinates (x, y)
2. Normal vector (z, w)

The normals are computed by the `NormalEstimator` (located in `include/nicp/normal_estimator.h`) which takes an input vector of points (`std::vector<Eigen::Vector2f>`) and output a vector of PointNormal2f (`std::vector<PointNormal2f>`). We provide a working module for normal estimation, however _feel free to implement your own system if you want_.

Furthermore, the ICP module should be slightly adjusted to handle `PointNormal2f` types. We provided some initial definitions in the `include/nicp/eigen_nicp_2d.h` header.

### TIPS
Regarding the Normal estimation, look at the definition of `NormalEstimator` to understand how it should be used.

For the __NICP__ module, we already provided the `OptimizeCorrespondences` method. Follow the structure of __ICP__ located in `include/icp/eigen_icp_2d.h` and `src/icp/eigen_icp_2d.cpp`.

## Frame-To-KeyFrame
As we seen during the lectures, Frame-To-Frame Odometry tends to accumulate a significant amount of drift over time due to small errors accumulated during the alignment phase of multiple scans.

To mitigate this, we can use a __Frame-To-KeyFrame__ approach: Instead of processing pairs of sequent scans, we "elevate" specific scans (KeyFrames or __KF__ ) to act as static anchors.

Let `X_keyframe_in_map` be the pose of the last KF with respect to the global frame (map) and let `X_moving_in_keyframe` be the pose of the last scan with respect to the last KF.
Conceptually, the Frame-To-KeyFrame algorithm can be represented as following:

```txt
def NormalFrameToKFOdometry(scan) {
    initial_guess = X_moving_in_keyframe
    X_moving_in_keyframe = NICP(fixed_scan, scan, initial_guess)

    float delta_t = X_moving_in_keyframe.translation().norm()
    float delta_r = angleFromR(X_moving_in_keyframe.linear())

    if (delta_t > keyframe_max_t || delta_r > keyframe_max_rot)
        X_keyframe_in_map = X_keyframe_in_map * X_moving_in_keyframe
        X_moving_in_keyframe.setIdentity();

    return X_keyframe_in_map * X_moving_in_keyframe
}

float angleFromR(R) {
    float c = R(0, 0);
    float s = R(0, 1);
    return atan2(s, c);
}
    
```

In the context of _Simultaneous Localization And Mapping_, the module you're writing is called `Tracker`, hence you will find a basic example of Frame-To-Frame Tracker in the `include/tracker.h` and `src/tracker.cpp` files.

Your task is to design a `NormalTracker` (`normal_tracker.h`,`normal_tracker.cpp`) which encapsule both the Frame-To-KeyFrame approach and the `NICP` solver.

### TIPS

- Start from the structure of the `Tracker`, understand how it works and then implement incrementally the requirements. You could start by constructing a Frame-to-KeyFrame P2P tracker and then finally include the NICP routines or vice-versa.

- We recommend visualizing the system by using RViZ. The initial setup provided in the `NormalTracker` provides the protected method `void publishKeyframe(const Eigen::Isometry2f keyframe_)` which extracts the translation component from the input pose and publish a `visualization_msgs::MarkerArray` on the `/info` topic. Visualizing this topic on RViZ, allows you to see the KeyFrame graph generated by your tracker.

- When your system will compile, you may start wondering how to determine the thresholds `keyframe_max_t` and `keyframe_max_rot`. These values represents the maximum distance and orientation difference between the last scan and the keyframe. During our tests, we noticed good results with `keyframe_max_t=2.0` and `keyframe_max_rot=0.5`. You can obtain better results by changing these parameters:
  - Lower thresholds approximates a Frame-To-Frame system resulting in less stable behavior
  - Higher thresholds results in fewer keyframes providing more stability __IF__ enough overlap between scans is present.


## General TIPS
- If you have doubts on how to link your package in the ROS environment, take a look at the `rp_10_scan_matcher` exercise and take a look at its README.